package vault_database;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import vault_database.DatabaseSettings.UninitializedSettingsException;
import vault_recording.DatabaseReadable;
import vault_recording.DatabaseWritable;

/**
 * DatabaseAccessProvider is used to access and modify data in a database. 
 * The class provides an easy to use interface for executing statements in the 
 * database.
 * 
 * @author Mikko Hilpinen
 * @since 17.7.2014
 */
public class DatabaseAccessor
{
	// ATTRIBUTES	------------------------------------------------------
	
	private String databaseName;
	private boolean open;
	
	private Connection currentConnection;
	
	
	// CONSTRUCTOR	------------------------------------------------------
	
	/**
	 * Creates a new DatabaseAccessProvider that will allow the modification 
	 * of the specified database
	 * 
	 * @param databaseName The name of the database to be used initially
	 */
	public DatabaseAccessor(String databaseName)
	{
		// Initializes attributes
		this.databaseName = databaseName;
		
		this.currentConnection = null;
		this.open = false;
	}

	
	// OTHER METHODS	--------------------------------------------------
	
	/**
	 * This method opens a connection to the formerly specified database. The 
	 * connection must be closed with {@link #closeConnection()} after the necessary 
	 * statements have been executed.
	 * @throws DatabaseUnavailableException If the connection couldn't be opened
	 * @see #closeConnection()
	 */
	private void openConnection() throws DatabaseUnavailableException
	{
		// If a connection is already open, quits
		if (this.open)
			return;
		
		// Tries to form a connection to the database
		try
		{
			this.currentConnection = DriverManager.getConnection(
					DatabaseSettings.getConnectionTarget() + this.databaseName, 
					DatabaseSettings.getUser(), DatabaseSettings.getPassword());
		}
		catch (SQLException | UninitializedSettingsException e)
		{
			throw new DatabaseUnavailableException(e);
		}
		
		this.open = true;
	}
	
	/**
	 * Closes a currently open connection to the database.
	 */
	public void closeConnection()
	{
		// If there is no connection, quits
		if (!this.open)
			return;
		
		// Closes the connection
		try
		{
			if (this.currentConnection != null)
				this.currentConnection.close();
		}
		catch (SQLException e)
		{
			System.err.println("DatabaseAccessProvider failed to close a "
					+ "connection to " + this.databaseName);
			e.printStackTrace();
			return;
		}
		
		this.open = false;
	}
	
	/**
	 * Executes a simple INSERT, UPDATE or DELETE statement. If you want to 
	 * execute a query or check the results of your statement, use 
	 * {@link #getPreparedStatement(String, boolean)} instead.
	 * 
	 * @param sqlStatement The statement that will be executed in the current 
	 * database
	 * @throws SQLException If the statement was malformed
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public void executeStatement(String sqlStatement) throws SQLException, 
			DatabaseUnavailableException
	{
		// Opens the connection if it isn't already
		if (!this.open)
			openConnection();
		
		if (sqlStatement == null)
			return;
		
		Statement statement = null;
		
		try
		{
			statement = this.currentConnection.createStatement();
			statement.executeUpdate(sqlStatement);
		}
		finally
		{
			closeStatement(statement);
		}
	}
	
	/**
	 * This method creates and returns a preparedStatment to the database. The 
	 * returned statement must be closed with {@link #closeStatement(Statement)} 
	 * after it has been used.
	 * 
	 * @param sqlStatement The sql statement that will be prepared. The 
	 * statement may include multiple '?'s as placeholders for future parameters.
	 * @param returnAutogeneratedKeys Should the returned PreparedStatement be 
	 * able to return the auto generated keys created during the execution. (default: false)
	 * @return a PreparedStatement based on the given sql statement
	 * @throws DatabaseUnavailableException If the database couldn't be accessed 
	 * @throws SQLException If the statement was malformed
	 */
	public PreparedStatement getPreparedStatement(String sqlStatement, 
			boolean returnAutogeneratedKeys) throws DatabaseUnavailableException, SQLException
	{
		// Opens the connection if it isn't already
		if (!this.open)
			openConnection();
		
		if (sqlStatement == null)
			throw new SQLException("No statement provided");
		
		PreparedStatement statement = null;
		
		try
		{
			int autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
			if (returnAutogeneratedKeys)
				autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
			
			statement = this.currentConnection.prepareStatement(sqlStatement, 
					autoGeneratedKeys);
			
			return statement;
		}
		catch (SQLException e)
		{
			// Closes the statement before throwing the exception
			closeStatement(statement);
			throw e;
		}
	}
	
	/**
	 * This method creates and returns a preparedStatment to the database. The 
	 * returned statement must be closed with {@link #closeStatement(Statement)} 
	 * after it has been used.
	 * 
	 * @param sqlStatement The sql statement that will be prepared. The 
	 * statement may include multiple '?'s as placeholders for future parameters.
	 * @return a PreparedStatement based on the given sql statement
	 * @throws DatabaseUnavailableException If the database couldn't be accessed 
	 * @throws SQLException If the statement was malformed
	 */
	public PreparedStatement getPreparedStatement(String sqlStatement) 
			throws DatabaseUnavailableException, SQLException
	{
		return getPreparedStatement(sqlStatement, false);
	}
	
	/**
	 * Changes the database that is currently being used
	 * 
	 * @param newDatabaseName The name of the new database to be used
	 * @return The name of the database used after the call of this method
	 */
	public String changeDatabase(String newDatabaseName)
	{
		// The change is simple when a connection is closed
		if (!this.open)
			this.databaseName = newDatabaseName;
		// When a connection is open, informs the server
		else
		{
			try
			{
				executeStatement("USE " + newDatabaseName + ";");
				this.databaseName = newDatabaseName;
			}
			catch (SQLException | DatabaseUnavailableException e)
			{
				System.err.println("DatabaseAccessor failed to change the database name");
				e.printStackTrace();
			}
		}
		
		return this.databaseName;
	}
	
	/**
	 * Closes a currently open statement
	 * 
	 * @param statement The statement that will be closed
	 */
	public static void closeStatement(Statement statement)
	{
		try
		{
			if (statement != null)
				statement.close();
		}
		catch (SQLException e)
		{
			System.err.println("DatabaseAccessProvider failed to close a statement");
			e.printStackTrace();
		}
	}
	
	/**
	 * Closes a currently open resultSet
	 * 
	 * @param resultSet The results that will be closed
	 */
	public static void closeResults(ResultSet resultSet)
	{
		try
		{
			if (resultSet != null)
				resultSet.close();
		}
		catch (SQLException e)
		{
			System.err.println("DatabaseAccessProvider failed to close a resultSet");
			e.printStackTrace();
		}
	}
	
	/**
	 * Performs a search through all the tables of a certain type in order to find the 
	 * matching column data.
	 * 
	 * @param table The table type that should contain the information
	 * @param keyColumn The name of the column where the key is
	 * @param keyValue The value which the column must have in order for the row to make it 
	 * to the result. No brackets required.
	 * @param valueColumn From which column the returned value is extracted from
	 * @return A list containing all the collected values
	 * @throws SQLException If the given values were invalid
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static List<String> findMatchingData(DatabaseTable table, String keyColumn, 
			String keyValue, String valueColumn) throws DatabaseUnavailableException, 
			SQLException
	{
		return findMatchingData(table, keyColumn, keyValue, valueColumn, -1);
	}
	
	/**
	 * Performs a search through all the tables of a certain type in order to find the 
	 * matching column data.
	 * 
	 * @param table The table type that should contain the information
	 * @param keyColumn The name of the column where the key is
	 * @param keyValue The value which the column must have in order for the row to make it 
	 * to the result. No brackets required.
	 * @param valueColumn From which column the returned value is extracted from
	 * @param limit The amount of results that should be returned at maximum. Use a negative 
	 * value if you don't want to pose a limit.
	 * @return A list containing all the collected values
	 * @throws SQLException If the given values were invalid
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static List<String> findMatchingData(DatabaseTable table, String keyColumn, 
			String keyValue, String valueColumn, int limit) throws DatabaseUnavailableException, 
			SQLException
	{
		String[] keyColumns = {keyColumn};
		String[] keyValues = {keyValue};
		
		return findMatchingData(table, keyColumns, keyValues, valueColumn, limit);
	}
	
	/**
	 * Performs a search through all the tables of a certain type in order to find the 
	 * matching column data.
	 * 
	 * @param table The table type that should contain the information
	 * @param keyColumns The names of the columns where the keys are
	 * @param keyValues The values which the columns must have in order for the row to make 
	 * it to the result. No brackets required.
	 * @param valueColumn From which column the returned value is extracted from
	 * @return A list containing all the collected values
	 * @throws SQLException If the given values were invalid
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static List<String> findMatchingData(DatabaseTable table, String[] keyColumns, 
			String[] keyValues, String valueColumn) throws DatabaseUnavailableException, 
			SQLException
	{
		return findMatchingData(table, keyColumns, keyValues, valueColumn, -1);
	}
	
	/**
	 * Performs a search through all the tables of a certain type in order to find the 
	 * matching column data.
	 * 
	 * @param table The table type that should contain the information
	 * @param keyColumns The names of the columns where the keys are
	 * @param keyValues The values which the columns must have in order for the row to make 
	 * it to the result. No brackets required.
	 * @param valueColumn From which column the returned value is extracted from
	 * @param limit The amount of results that should be returned at maximum. Use a negative 
	 * value if you don't want to pose a limit.
	 * @return A list containing all the collected values
	 * @throws SQLException If the given values were invalid
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static List<String> findMatchingData(DatabaseTable table, String[] keyColumns, 
			String[] keyValues, String valueColumn, int limit) throws 
			DatabaseUnavailableException, SQLException
	{
		List<String> resultData = new ArrayList<>();
		
		// Performs a database query
		DatabaseAccessor accessor = new DatabaseAccessor(table.getDatabaseName());
		
		try
		{
			int tables = DatabaseSettings.getTableHandler().getTableAmount(table);
			int matchesFound = 0;
			
			// Goes through all the userData tables in order
			for (int i = 1; i <= tables; i++)
			{	
				StringBuilder statementString = new StringBuilder("SELECT * FROM " + 
						table.getTableName() + i);
				
				if (keyColumns.length > 0)
				{
					statementString.append(" WHERE ");
					for (int keyIndex = 0; keyIndex < keyColumns.length; keyIndex ++)
					{
						if (keyIndex != 0)
							statementString.append(" AND ");
						statementString.append(keyColumns[keyIndex] + " = '" + 
								keyValues[keyIndex] + "'");
					}
				}
				
				// The amount of returned values may be limited already in the query
				if (limit >= 0)
					statementString.append(" LIMIT " + (limit - matchesFound));
				
				PreparedStatement statement = null;
				ResultSet results = null;
				
				try
				{
					statement = accessor.getPreparedStatement(statementString.toString());
					results = statement.executeQuery();
					
					while (results.next())
					{
						resultData.add(results.getString(valueColumn));
						matchesFound ++;
					}
				}
				finally
				{
					DatabaseAccessor.closeResults(results);
					DatabaseAccessor.closeStatement(statement);
					
					if (limit >= 0 && matchesFound >= limit)
						break;
				}
			}
		}
		finally
		{
			accessor.closeConnection();
		}
		return resultData;
	}
	
	/**
	 * Finds the primary keys from the rows with matching data
	 * @param table The table that is searched through
	 * @param keyColumn The name of the column that holds the key data
	 * @param keyValue The key data that is searched for
	 * @return A list of all the primary keys with matching data
	 * @throws DatabaseUnavailableException If the database couldn't be reached
	 * @throws SQLException If the search couldn't be performed
	 * @throws InvalidTableTypeException If the table doesn't have a primary key column
	 */
	public static List<String> findMatchingIDs(DatabaseTable table, 
			String keyColumn, String keyValue) throws DatabaseUnavailableException, 
			SQLException, InvalidTableTypeException
	{
		checkPrimaryKeyColumn(table);
		return DatabaseAccessor.findMatchingData(table, keyColumn, keyValue, 
				table.getPrimaryColumnName());
	}
	
	/**
	 * Finds the primary keys from the rows with matching data
	 * @param table The table that is searched through
	 * @param keyColumns The names of the columns that hold the key data
	 * @param keyValues The key data that is searched for
	 * @return A list of all the primary keys with matching data
	 * @throws DatabaseUnavailableException If the database couldn't be reached
	 * @throws SQLException If the search couldn't be performed
	 * @throws InvalidTableTypeException If the table doesn't have a primary key column
	 */
	public static List<String> findMatchingIDs(DatabaseTable table, String[] keyColumns, 
			String[] keyValues) throws DatabaseUnavailableException, SQLException, InvalidTableTypeException
	{
		checkPrimaryKeyColumn(table);
		return DatabaseAccessor.findMatchingData(table, keyColumns, keyValues, 
				table.getPrimaryColumnName());
	}
	
	/**
	 * Finds the primary keys from the rows with matching data
	 * @param table The table that is searched through
	 * @param keyColumn The name of the column that holds the key data
	 * @param keyValue The key data that is searched for
	 * @param limit How many keys will be returned at maximum
	 * @return A list of all the primary keys with matching data
	 * @throws DatabaseUnavailableException If the database couldn't be reached
	 * @throws SQLException If the search couldn't be performed
	 * @throws InvalidTableTypeException If the table doesn't have a primary key column
	 */
	public static List<String> findMatchingIDs(DatabaseTable table, 
			String keyColumn, String keyValue, int limit) throws DatabaseUnavailableException, 
			SQLException, InvalidTableTypeException
	{
		checkPrimaryKeyColumn(table);
		return DatabaseAccessor.findMatchingData(table, keyColumn, keyValue, 
				table.getPrimaryColumnName(), limit);
	}
	
	/**
	 * Finds the primary keys from the rows with matching data
	 * @param table The table that is searched through
	 * @param keyColumns The names of the columns that hold the key data
	 * @param keyValues The key data that is searched for
	 * @param limit How many keys will be returned at maximum
	 * @return A list of all the primary keys with matching data
	 * @throws DatabaseUnavailableException If the database couldn't be reached
	 * @throws SQLException If the search couldn't be performed
	 * @throws InvalidTableTypeException If the table doesn't have a primary key column
	 */
	public static List<String> findMatchingIDs(DatabaseTable table, String[] keyColumns, 
			String[] keyValues, int limit) throws DatabaseUnavailableException, SQLException, 
			InvalidTableTypeException
	{
		checkPrimaryKeyColumn(table);
		return DatabaseAccessor.findMatchingData(table, keyColumns, keyValues, 
				table.getPrimaryColumnName(), limit);
	}
	
	/**
	 * Inserts new data to the given table.
	 * @param targetTable The table the data will be inserted into
	 * @param columnData The data posted to the table (in the same order as in the tables). 
	 * All data will be considered to be strings. No brackets are required around any piece of 
	 * data. If the table uses auto-increment indexing, the columnData shouldn't contain the 
	 * primary key and it should be placed first in the table.
	 * @return The integer index if one was generated during auto-increment indexing. -1 otherwise.
	 * @throws SQLException If the insert failed
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 * @throws InvalidTableTypeException If the table uses integer indexing but not 
	 * auto-increment indexing
	 */
	public static int insert(DatabaseTable targetTable, List<String> columnData) throws 
			SQLException, DatabaseUnavailableException, InvalidTableTypeException
	{
		return insert(targetTable, getColumnDataString(columnData));
	}
	
	/**
	 * Inserts new data to the given table.
	 * @param targetTable The table the data will be inserted into
	 * @param columnData The data posted to the table (in the same order as in the tables). 
	 * All data will be considered to be strings. No brackets are required around any piece of 
	 * data. The index should be included.
	 * @param newID The identifier of the new entity
	 * @throws SQLException If the insert failed
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static void insert(DatabaseTable targetTable, List<String> columnData, int newID) 
			throws SQLException, DatabaseUnavailableException
	{
		insert(targetTable, getColumnDataString(columnData), newID);
	}
	
	/**
	 * Inserts new data to the given table.
	 * @param targetTable The table the data will be inserted into
	 * @param columnData The data posted to the table (in the same order as in the tables). 
	 * Strings need to be surrounded with brackets ('). 
	 * If the table uses auto-increment indexing, the columnData shouldn't contain the 
	 * primary key and it should be placed first in the table.
	 * @return The integer index if one was generated during auto-increment indexing. -1 otherwise.
	 * @throws SQLException If the insert failed
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 * @throws InvalidTableTypeException If the table uses indexing but not auto-increment indexing.
	 */
	public static int insert(DatabaseTable targetTable, String columnData) throws 
			SQLException, DatabaseUnavailableException, InvalidTableTypeException
	{
		if (targetTable.usesAutoIncrementIndexing())
			return insertWithAutoIncrement(targetTable, columnData);
		else
		{
			if (targetTable.usesIntegerIndexing())
				throw new InvalidTableTypeException("No index provided on indexed table insert");
			
			insert(targetTable, columnData, -1);
			return -1;
		}
	}
	
	/**
	 * Inserts new data to the given table
	 * @param targetTable The table the data will be inserted into
	 * @param columnData The data posted to the table (in the same order as in the tables). 
	 * No brackets required. Strings need to be surrounded with brackets ('). 
	 * The index should be included.
	 * @param newID The identifier of the object that is being inserted
	 * @throws SQLException If the insert failed
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static void insert(DatabaseTable targetTable, String columnData, int newID) throws 
			SQLException, DatabaseUnavailableException
	{
		// Opens connection
		DatabaseAccessor accessor = new DatabaseAccessor(targetTable.getDatabaseName());
		
		// Inserts data
		try
		{
			accessor.executeStatement(getInsertStatement(targetTable, columnData, newID));
		}
		finally
		{
			// Closes connection
			accessor.closeConnection();
		}
		
		// Updates the table amounts
		if (targetTable.usesIntegerIndexing())
			DatabaseSettings.getTableHandler().updateTableAmount(targetTable, newID);
	}
	
	/**
	 * Inserts the object's data into the database. If the object's data already exists in the 
	 * database, updates it instead of inserting new data.
	 * @param object The object that will be written into the database
	 * @throws SQLException If the writing fails
	 * @throws DatabaseUnavailableException If the database can't be accessed
	 */
	public static void insert(DatabaseWritable object) throws SQLException, 
			DatabaseUnavailableException
	{
		try
		{
			// If the object already exists, updates it instead
			if (objectIsInDatabase(object))
				update(object);
			else
			{
				// Finds the object's column data
				List<String> columnNames = object.getTable().getColumnNames();
				List<String> columnValues = new ArrayList<>();
				for (String columnName : columnNames)
				{
					columnValues.add(object.getColumnValue(columnName));
				}
				
				// If auto-increment indexing is used, the object will be informed accordingly
				if (object.getTable().usesAutoIncrementIndexing())
				{
					// Modifies column data (doesn't include the first auto-increment slot)
					columnValues.remove(0);
					
					object.newIndexGenerated(insert(object.getTable(), columnValues));
				}
				else
				{
					// Otherwise the index will be provided by the object
					if (object.getTable().usesIntegerIndexing())
					{
						int newIndex = Integer.parseInt(object.getColumnValue(
								object.getTable().getPrimaryColumnName()));
						insert(object.getTable(), columnValues, newIndex);
					}
					// Or not used at all
					else
						insert(object.getTable(), columnValues);
				}
			}
		}
		catch (InvalidTableTypeException e)
		{
			// This should never be reached
			System.err.println(
					"DatabaseAccessor.insert(DatabaseWritable) isn't working correctly");
		}
	}
	
	/**
	 * Deletes certain data from all the tables of the given type
	 * @param targetTable The table type from which data is removed
	 * @param targetColumn The column which is used for checking whether data should be deleted.
	 * @param targetValue The value which the column must have in order for the data to be 
	 * deleted. Brackets aren't necessary.
	 * @throws SQLException If the deletion failed
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static void delete(DatabaseTable targetTable, String targetColumn, 
			String targetValue) throws SQLException, DatabaseUnavailableException
	{
		DatabaseAccessor accessor = new DatabaseAccessor(targetTable.getDatabaseName());
		
		try
		{
			for (int i = 1; i <= DatabaseSettings.getTableHandler().getTableAmount(targetTable); i++)
			{
				StringBuilder statement = new StringBuilder("DELETE from ");
				statement.append(targetTable.getTableName());
				statement.append(i);
				statement.append(" WHERE ");
				statement.append(targetColumn);
				statement.append(" = '");
				statement.append(targetValue);
				statement.append("';");
				
				accessor.executeStatement(statement.toString());
			}
		}
		finally
		{
			accessor.closeConnection();
		}
	}
	
	/**
	 * Updates a value in a column for certain rows
	 * @param table The table in which the update is done
	 * @param targetColumn The column which should contain the targetValue
	 * @param targetValue The value the column should have in order to be updated. No brackets 
	 * needed.
	 * @param changeColumn The column which is being updated
	 * @param newValue The new value given to the changeColumn. No brackets needed.
	 * @throws SQLException If the update fails
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static void update(DatabaseTable table, String targetColumn, 
			String targetValue, String changeColumn, String newValue) throws SQLException, 
			DatabaseUnavailableException
	{
		String[] changeColumns = {changeColumn};
		String[] newValues = {newValue};
		update(table, targetColumn, targetValue, changeColumns, newValues);
	}
	
	/**
	 * Updates a set of columns for certain rows
	 * @param table The table in which the update is done
	 * @param targetColumn The column which should contain the targetValue
	 * @param targetValue The value the column should have in order to be updated. No brackets 
	 * needed.
	 * @param changeColumns The columns which are being updated
	 * @param newValues The new values given to the changeColumns. No brackets needed.
	 * @throws SQLException If the update fails
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static void update(DatabaseTable table, String targetColumn, String targetValue, 
			String[] changeColumns, String[] newValues) throws SQLException, DatabaseUnavailableException
	{
		DatabaseAccessor accessor = new DatabaseAccessor(table.getDatabaseName());
		
		try
		{
			for (int i = 1; i <= DatabaseSettings.getTableHandler().getTableAmount(table); i++)
			{
				StringBuilder statementBuilder = new StringBuilder("UPDATE ");
				statementBuilder.append(table.getTableName() + i);
				statementBuilder.append(" SET ");
				
				for (int columnIndex = 0; columnIndex < changeColumns.length; columnIndex ++)
				{
					if (columnIndex != 0)
						statementBuilder.append(", ");
					statementBuilder.append(changeColumns[columnIndex] + " = '" + 
						newValues[columnIndex] + "'");
				}
				
				statementBuilder.append(" WHERE " + targetColumn + " = '" + targetValue + "'");
				
				accessor.executeStatement(statementBuilder.toString());
			}
		}
		finally
		{
			accessor.closeConnection();
		}
	}
	
	/**
	 * Updates an object's data into the database. If the object doesn't exist in the 
	 * database, nothing is changed.
	 * @param object The object whose data will be updated to the database.
	 * @throws InvalidTableTypeException If the object's table doesn't have a primary column.
	 * @throws SQLException If the operation failed.
	 * @throws DatabaseUnavailableException If the database couldn't be reached.
	 */
	public static void update(DatabaseWritable object) throws InvalidTableTypeException, 
			SQLException, DatabaseUnavailableException
	{
		// This only works if the object table uses primary keys and the object has one
		String primaryColumnName = object.getTable().getPrimaryColumnName();
		if (primaryColumnName == null)
			throw new InvalidTableTypeException("The table " + object.getTable() + 
					" doesn't have a primary column");
		
		String id = object.getColumnValue(primaryColumnName);
		if (id == null)
			return;
		
		// Collects the data required for the operation
		List<String> updatedColumns = object.getTable().getColumnNames();
		updatedColumns.remove(primaryColumnName);
		String[] updatedValues = new String[updatedColumns.size()];
		for (int i = 0; i < updatedValues.length; i++)
		{
			updatedValues[i] = object.getColumnValue(updatedColumns.get(i));
		}
		
		// Performs the update
		update(object.getTable(), primaryColumnName, id, 
				updatedColumns.toArray(new String[0]), updatedValues);
	}
	
	/**
	 * Checks if an object already has its data stored in a database. If the object's table 
	 * doesn't have a primary column, this can't be determined and false will be returned.
	 * @param object The object that may or may not exist in the database
	 * @return Does the database already contain the object's data
	 * @throws DatabaseUnavailableException If the database couldn't be reached
	 * @throws SQLException If the operation failed
	 */
	public static boolean objectIsInDatabase(DatabaseWritable object) throws 
			DatabaseUnavailableException, SQLException
	{
		// If the table doesn't have primary columns, can't determine if the object exists 
		// in the table
		String primaryColumnName = object.getTable().getPrimaryColumnName();
		if (primaryColumnName == null)
			return false;
		
		String id = object.getColumnValue(object.getTable().getPrimaryColumnName());
		
		// If the object can't determine it's id, it is probably collecting it from 
		// auto-increment data and hence not written yet
		if (id == null)
			return false;
		
		// Otherwise simply checks if the primary key is in use
		return !findMatchingData(object.getTable(), primaryColumnName, id, primaryColumnName, 
				1).isEmpty();
	}
	
	/**
	 * Reads the object's data from the database and informs the object
	 * @param object The object that will be informed about the readings
	 * @param objectIdentifier The identifier with which the object is stored in the database 
	 * (primary key)
	 * @return Could any data be found. If false, the object may be unusable.
	 * @throws DatabaseUnavailableException If the database couldn't be reached.
	 * @throws SQLException If the operation failed.
	 */
	public static boolean readObjectData(DatabaseReadable object, String objectIdentifier) 
			throws DatabaseUnavailableException, SQLException
	{
		DatabaseAccessor accessor = null;
		PreparedStatement statement = null;
		ResultSet results = null;
		
		try
		{
			accessor = new DatabaseAccessor(object.getTable().getDatabaseName());
			
			// Parses the identifier, if necessary
			int id = 0;
			if (object.getTable().usesIntegerIndexing())
				id = Integer.parseInt(objectIdentifier);
			
			statement = accessor.getPreparedStatement(new StringBuilder(
					"SELECT * FROM ").append(
					DatabaseSettings.getTableHandler().getTableNameForIndex(object.getTable(), 
					id, false)).append(" WHERE ").append(
					object.getTable().getPrimaryColumnName()).append(" = '").append(
					objectIdentifier + "'").toString());
			
			results = statement.executeQuery();
			
			if (results.next())
			{
				// Goes through the columns and informs the object about their contents
				for (String field : object.getTable().getColumnNames())
				{
					object.setValue(field, results.getString(field));
				}
				
				return true;
			}
			else
				return false;
		}
		finally
		{
			if (accessor != null)
				accessor.closeConnection();
		}
	}
	
	/**
	 * Inserts new data into the given table while also collecting and returning the 
	 * auto-generated id. Also informs the multiTableHandler about the addition. This 
	 * should be used for auto-indexing tables.
	 * @param targetTable The table the data is inserted into
	 * @param columnData The data posted to the table (in the same order as in the tables). 
	 * Strings need to be surrounded with brackets (')
	 * @param idColumnName The name of the auto-increment id column
	 * @return The id generated during the insert
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 * @throws SQLException If the insert failed or if the table doesn't use auto-increment 
	 * indexing
	 * @throws InvalidTableTypeException If the table doesn't use auto-increment indexing
	 */
	private static int insertWithAutoIncrement(DatabaseTable targetTable, String columnData) 
			throws SQLException, DatabaseUnavailableException, InvalidTableTypeException
	{
		// Doesn't work if the table doesn't use auto-increment
		if (!targetTable.usesAutoIncrementIndexing())
			throw new InvalidTableTypeException(
					"No id can be retrieved since the table doesn't use auto-increment indexing");
		
		DatabaseAccessor accessor = new DatabaseAccessor(targetTable.getDatabaseName());
		PreparedStatement statement = null;
		ResultSet autoKeys = null;
		
		try
		{
			statement = accessor.getPreparedStatement(getInsertStatement(targetTable, 
					columnData, -1), true);
			statement.execute();
			
			autoKeys = statement.getGeneratedKeys();
			
			if (autoKeys.next())
			{
				int id = autoKeys.getInt(targetTable.getPrimaryColumnName());
				DatabaseSettings.getTableHandler().updateTableAmount(targetTable, id);
				return id;
			}
		}
		finally
		{
			DatabaseAccessor.closeResults(autoKeys);
			DatabaseAccessor.closeStatement(statement);
			accessor.closeConnection();
		}
		
		return 0;
	}
	
	private static String getColumnDataString(List<String> columnData)
	{
		StringBuilder columnDataString = new StringBuilder();
		
		for (int i = 0; i < columnData.size(); i++)
		{
			if (i != 0)
				columnDataString.append(", ");
			columnDataString.append("'" + columnData.get(i) + "'");
		}
		
		return columnDataString.toString();
	}
	
	/*
	private static String getInsertStatement(DatabaseTable table, List<String> columnData)
	{
		return getInsertStatement(table, getColumnDataString(columnData));
	}
	*/
	
	private static String getInsertStatement(DatabaseTable table, String columnDataString, 
			int index)
	{
		StringBuilder statement = new StringBuilder();
		statement.append("INSERT INTO ");
		
		if (index < 0)
			statement.append(DatabaseSettings.getTableHandler().getLatestTableName(table));
		else
			statement.append(DatabaseSettings.getTableHandler().getTableNameForIndex(
					table, index, true));
		
		statement.append(" values (");
		
		if (table.usesAutoIncrementIndexing())
			statement.append("null, ");
			
		statement.append(columnDataString);
		
		statement.append(");");
		
		return statement.toString();
	}
	
	private static void checkPrimaryKeyColumn(DatabaseTable table) throws InvalidTableTypeException
	{
		if (table.getPrimaryColumnName() == null)
			throw new InvalidTableTypeException(
					"table " + table + " doesn't have a primary key column");
	}
}
