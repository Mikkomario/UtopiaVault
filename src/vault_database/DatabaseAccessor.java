package vault_database;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import vault_database.DatabaseSettings.UninitializedSettingsException;

/**
 * DatabaseAccessProvider is used to access and modify data in a database. 
 * The class provides an easy to use interface for executing statements in the 
 * database.
 * 
 * @author Mikko Hilpinen
 * @since 17.7.2014
 */
public class DatabaseAccessor
{
	// ATTRIBUTES	------------------------------------------------------
	
	private String databaseName;
	private boolean open;
	
	private Connection currentConnection;
	
	
	// CONSTRUCTOR	------------------------------------------------------
	
	/**
	 * Creates a new DatabaseAccessProvider that will allow the modification 
	 * of the specified database
	 * 
	 * @param databaseName The name of the database to be used initially
	 */
	public DatabaseAccessor(String databaseName)
	{
		// Initializes attributes
		this.databaseName = databaseName;
		
		this.currentConnection = null;
		this.open = false;
	}

	
	// OTHER METHODS	--------------------------------------------------
	
	/**
	 * This method opens a connection to the formerly specified database. The 
	 * connection must be closed with {@link #closeConnection()} after the necessary 
	 * statements have been executed.
	 * @throws DatabaseUnavailableException If the connection couldn't be opened
	 * @see #closeConnection()
	 */
	private void openConnection() throws DatabaseUnavailableException
	{
		// If a connection is already open, quits
		if (this.open)
			return;
		
		// Tries to form a connection to the database
		try
		{
			this.currentConnection = DriverManager.getConnection(
					DatabaseSettings.getConnectionTarget() + this.databaseName, 
					DatabaseSettings.getUser(), DatabaseSettings.getPassword());
		}
		catch (SQLException | UninitializedSettingsException e)
		{
			throw new DatabaseUnavailableException(e);
		}
		
		this.open = true;
	}
	
	/**
	 * Closes a currently open connection to the database.
	 */
	public void closeConnection()
	{
		// If there is no connection, quits
		if (!this.open)
			return;
		
		// Closes the connection
		try
		{
			if (this.currentConnection != null)
				this.currentConnection.close();
		}
		catch (SQLException e)
		{
			System.err.println("DatabaseAccessProvider failed to close a "
					+ "connection to " + this.databaseName);
			e.printStackTrace();
			return;
		}
		
		this.open = false;
	}
	
	/**
	 * Executes a simple INSERT, UPDATE or DELETE statement. If you want to 
	 * execute a query or check the results of your statement, use 
	 * {@link #getPreparedStatement(String, boolean)} instead.
	 * 
	 * @param sqlStatement The statement that will be executed in the current 
	 * database
	 * @throws SQLException If the statement was malformed
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public void executeStatement(String sqlStatement) throws SQLException, 
			DatabaseUnavailableException
	{
		// Opens the connection if it isn't already
		if (!this.open)
			openConnection();
		
		if (sqlStatement == null)
			return;
		
		Statement statement = null;
		
		try
		{
			statement = this.currentConnection.createStatement();
			statement.executeUpdate(sqlStatement);
		}
		finally
		{
			closeStatement(statement);
		}
	}
	
	/**
	 * This method creates and returns a preparedStatment to the database. The 
	 * returned statement must be closed with {@link #closeStatement(Statement)} 
	 * after it has been used.
	 * 
	 * @param sqlStatement The sql statement that will be prepared. The 
	 * statement may include multiple '?'s as placeholders for future parameters.
	 * @param returnAutogeneratedKeys Should the returned PreparedStatement be 
	 * able to return the auto generated keys created during the execution. (default: false)
	 * @return a PreparedStatement based on the given sql statement
	 * @throws DatabaseUnavailableException If the database couldn't be accessed 
	 * @throws SQLException If the statement was malformed
	 */
	public PreparedStatement getPreparedStatement(String sqlStatement, 
			boolean returnAutogeneratedKeys) throws DatabaseUnavailableException, SQLException
	{
		// Opens the connection if it isn't already
		if (!this.open)
			openConnection();
		
		if (sqlStatement == null)
			throw new SQLException("No statement provided");
		
		PreparedStatement statement = null;
		
		try
		{
			int autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
			if (returnAutogeneratedKeys)
				autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
			
			statement = this.currentConnection.prepareStatement(sqlStatement, 
					autoGeneratedKeys);
			
			return statement;
		}
		catch (SQLException e)
		{
			// Closes the statement before throwing the exception
			closeStatement(statement);
			throw e;
		}
	}
	
	/**
	 * This method creates and returns a preparedStatment to the database. The 
	 * returned statement must be closed with {@link #closeStatement(Statement)} 
	 * after it has been used.
	 * 
	 * @param sqlStatement The sql statement that will be prepared. The 
	 * statement may include multiple '?'s as placeholders for future parameters.
	 * @return a PreparedStatement based on the given sql statement
	 * @throws DatabaseUnavailableException If the database couldn't be accessed 
	 * @throws SQLException If the statement was malformed
	 */
	public PreparedStatement getPreparedStatement(String sqlStatement) 
			throws DatabaseUnavailableException, SQLException
	{
		return getPreparedStatement(sqlStatement, false);
	}
	
	/**
	 * Closes a currently open statement
	 * 
	 * @param statement The statement that will be closed
	 */
	public static void closeStatement(Statement statement)
	{
		try
		{
			if (statement != null)
				statement.close();
		}
		catch (SQLException e)
		{
			System.err.println("DatabaseAccessProvider failed to close a statement");
			e.printStackTrace();
		}
	}
	
	/**
	 * Closes a currently open resultSet
	 * 
	 * @param resultSet The results that will be closed
	 */
	public static void closeResults(ResultSet resultSet)
	{
		try
		{
			if (resultSet != null)
				resultSet.close();
		}
		catch (SQLException e)
		{
			System.err.println("DatabaseAccessProvider failed to close a resultSet");
			e.printStackTrace();
		}
	}
	
	/**
	 * Changes the database that is currently being used
	 * 
	 * @param newDatabaseName The name of the new database to be used
	 * @return The name of the database used after the call of this method
	 */
	public String changeDatabase(String newDatabaseName)
	{
		// The change is simple when a connection is closed
		if (!this.open)
			this.databaseName = newDatabaseName;
		// When a connection is open, informs the server
		else
		{
			try
			{
				executeStatement("USE " + newDatabaseName + ";");
				this.databaseName = newDatabaseName;
			}
			catch (SQLException | DatabaseUnavailableException e)
			{
				System.err.println("DatabaseAccessor failed to change the database name");
				e.printStackTrace();
			}
		}
		
		return this.databaseName;
	}
	
	/**
	 * Performs a search through all the tables of a certain type in order to find the 
	 * matching column data.
	 * 
	 * @param table The table type that should contain the information
	 * @param keyColumn The name of the column where the key is
	 * @param keyValue The value which the row must have in order for it to make it to the result
	 * @param valueColumn From which column the returned value is extracted from
	 * @return A list containing all the collected values
	 * @throws SQLException If the given values were invalid
	 * @throws DatabaseUnavailableException If the database couldn't be accessed
	 */
	public static String findFirstData(DatabaseTable table, String keyColumn, 
			String keyValue, String valueColumn) throws DatabaseUnavailableException, 
			SQLException
	{
		List<String> resultData = new ArrayList<>();
		
		// Performs a database query
		DatabaseAccessor accessor = new DatabaseAccessor(table.getDatabaseName());
		
		int tables = DatabaseSettings.getTableHandler().getTableAmount(table);
		
		// Goes through all the userData tables in order
		for (int i = 1; i <= tables; i++)
		{			
			PreparedStatement statement = accessor.getPreparedStatement(
					"SELECT * FROM " + table.getTableName() + i + 
					" WHERE " + keyColumn + " = " + keyValue, false);
			ResultSet results = null;
			
			results = statement.executeQuery();
			
			while (results.next())
			{
				resultData.add(results.getString(valueColumn));
			}
			
			DatabaseAccessor.closeResults(results);
			DatabaseAccessor.closeStatement(statement);
		}
		
		accessor.closeConnection();
		return null;
	}
}
